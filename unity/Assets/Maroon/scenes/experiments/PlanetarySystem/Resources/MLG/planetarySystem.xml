<?xml version="1.0" encoding="utf-8"?>
<LanguageManager>
    <Translations>
        <Translation Key="hidePlanets">
            <English>hide planets</English>
            <German>Planeten ausblenden</German>
        </Translation>

		
		
		
		
		
        <Translation Key="SortingAlgorithm">
            <English>Sorting Algorithm</English>
            <German>Sortier-Algorithmus</German>
        </Translation>


        <Translation Key="StylizedSwapPrefix">
            <English>&lt;b>Swaps:&lt;/b> &lt;pos=50%></English>
            <German>&lt;b>Tausche:&lt;/b> &lt;pos=50%></German>
        </Translation>

        <Translation Key="StylizedComparisonPrefix">
            <English>&lt;b>Comparisons:&lt;/b> &lt;pos=50%></English>
            <German>&lt;b>Vergleiche:&lt;/b> &lt;pos=50%></German>
        </Translation>

        
        <!-- Helpi Messages -->
        <Translation Key="EnterSortingExperiment">
            <English>Welcome! Here you can get to know different sorting algorithms. Switch to battle mode to let them compete against each other.</English>
            <German>Willkommen! Hier kannst du verschiedene Sortier-Algorithmen kennenlernen. Wechsle zum Battle-Modus, um sie gegeneinander antreten zu lassen.</German>
        </Translation>
      
        <!-- Descriptions -->
        <Translation Key="Insertion Sort Description">
            <English>&lt;style="sortingFunction">Insertion Sort&lt;/style> starts with the second element, compares it to the first, and arranges them accordingly. Then it takes the third element and &lt;b>inserts&lt;/b> it in the right position. This is iteratively repeated for the whole field, so the front elements are always sorted.</English>
            <German>&lt;style="sortingFunction">Insertion Sort&lt;/style> startet mit dem zweiten Element, vergleicht es mit dem Ersten und sortiert die beiden. Dann nimmt es das dritte Element und &lt;b>fügt&lt;/b> es an der passenden Stelle &lt;b>ein&lt;/b>. Dies wird iterativ für alle Elemente wiederholt, somit sind die vorderen Elemente immer sortiert.</German>
        </Translation>

        <Translation Key="Merge Sort Description">
            <English>&lt;style="sortingFunction">Merge Sort&lt;/style> splits the elements into two halves. It recursively splits these halves further and sorts them individually. Once it can not split the halves any further, or the two parts have already been sorted, it &lt;b>merges&lt;/b> them. Merging happens by always comparing the leftmost elements of both halves and arranging them accordingly.</English>
            <German>&lt;style="sortingFunction">Merge Sort&lt;/style> teilt die Elemente in zwei Hälften. Diese Hälften werden rekursiv weiter aufgeteilt und getrennt sortiert. Wenn die Hälften nicht weiter getrennt werden können, oder bereits sortiert wurden, werden sie &lt;b>zusammengefügt&lt;/b>. Dazu wird jeweils das kleinste Element der linken Seite mit dem kleinsten der rechten Seite verglichen und eingeordnet.</German>
        </Translation>

        <Translation Key="Heap Sort Description">
            <English>&lt;style="sortingFunction">Heapsort&lt;/style> uses the maximum &lt;b>heap&lt;/b> data structure to sort the elements. This data structure always has the maximum element as its root element. The algorithm first builds a maximum heap of all elements. It then moves the root to the last unsorted position and again builds a heap of the remaining elements, using the fact that they are already pre-sorted. This is iteratively repeated until all elements are sorted, so the back always contains the sorted elements.</English>
            <German>&lt;style="sortingFunction">Heapsort&lt;/style> verwendet die Maximum-&lt;b>Halde&lt;/b> Datenstruktur um die Elemente zu sortieren. Diese Datenstruktur hat immer das größte Element als Wurzel. Zuerst wird eine Maximum-Halde aus allen Elementen erzeugt. Dann wird das Wurzel-Element an die letzte unsortierte Stelle verschoben und aus den restlichen Elementen wird wieder eine Maximum-Halde erzeugt. Dabei wird ausgenutzt, dass die Elemente bereits vorsortiert sind. Dies wird iterativ wiederholt, bis alle Elemente sortiert sind. Die hinteren Elemente sind dabei die sortierten.</German>
        </Translation>

        <Translation Key="Quick Sort Description">
            <English>&lt;style="sortingFunction">Quicksort&lt;/style> sorts the elements using a &lt;b>pivot&lt;/b> element. It moves all elements smaller than the pivot to the left of the field. All bigger ones move to the right. It then places the pivot in the middle and sorts the left and right parts recursively.</English>
            <German>&lt;style="sortingFunction">Quicksort&lt;/style> sortiert die Elemente anhand von einem &lt;b>Pivot&lt;/b>-Element. Alle Elemente, die kleiner sind als das Pivot-Element, werden nach links verschoben, alle die größer sind nach rechts. Das Pivot-Element wird in die Mitte platziert und der linke und rechte Teil werden rekusiv sortiert.</German>
        </Translation>

       
        
    </Translations>
</LanguageManager>
